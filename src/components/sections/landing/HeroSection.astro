---

import { Icon } from "astro-icon/components";
import { Button } from "@/components/starwind/button";
import AnimatedHeroSvg from "@/components/ui/blocks/AnimatedHeroSvg.astro";

// Define props from Astro
const {
  title,
  typingTitles,
  description,
  paragraph1,
  paragraph2,
  primaryBtn,
  primaryBtnURL,
  secondaryBtn,
  secondaryBtnURL,
  heroImg,
  heroImgAlt,
  heroSvg,
} = Astro.props;

// Define TypeScript interface for props
interface Props {
  title: string;
  typingTitles?: string[];
  description?: string;
  paragraph1?: string;
  paragraph2?: string;
  primaryBtn?: string;
  primaryBtnURL?: string;
  secondaryBtn?: string;
  secondaryBtnURL?: string;
  heroImg?: string;
  heroImgAlt?: string;
  heroSvg?: string;
}
---

<!-- Defining a grid container that holds all the content -->
<section class="mb-12 grid items-center gap-4 lg:grid-cols-[3fr_2fr] lg:gap-8">
  <!-- Title and description -->
  <div class="space-y-4 text-slate-800 dark:text-slate-200">
    <h1 class="m-0 text-2xl font-bold text-balance sm:text-4xl xl:text-5xl">
      <!-- About Fragment: https://docs.astro.build/en/basics/astro-syntax/#fragments -->
      <Fragment set:html={title} />
    </h1>
    <h2
      id="typing-subtitle"
      class="text-2xl font-bold sm:text-4xl xl:text-5xl"
      data-typing-titles={JSON.stringify(typingTitles)}
    >
      <span
        class="typing-text bg-linear-to-r from-orange-700 via-fuchsia-600 to-cyan-700 bg-clip-text text-transparent dark:from-orange-400 dark:via-cyan-400 dark:to-green-500"
      ></span>
      <span
        class="typing-cursor animate-blink font-extrabold text-orange-600 dark:text-yellow-400"
        >|</span
      >
    </h2>
    <p
      class="mb-4 text-xl font-semibold text-pretty text-cyan-800 italic dark:text-cyan-300"
    >
      {description}
    </p>
    <p class="leading-relaxed text-pretty">
      <Fragment set:html={paragraph1} />
    </p>
    <p class="leading-relaxed text-pretty">
      <Fragment set:html={paragraph2} />
    </p>

    <!-- Action Button Section: This section includes two CTAs with their own styles and URL -->
    <div
      class="mt-8 flex w-full flex-wrap justify-center gap-4 sm:justify-start"
    >
      {
        primaryBtn && (
          <Button href={primaryBtnURL}>
            <Icon name="InfoFill" class="size-6" />
            {primaryBtn}
          </Button>
        )
      }
      {
        secondaryBtn && (
          <Button variant="secondary" href={secondaryBtnURL}>
            <Icon name="ChatAnimate" class="size-6" />
            {secondaryBtn}
          </Button>
        )
      }
    </div>
  </div>
  <!-- Hero Image Section -->
  <div>
    <!-- Render either a raster image or SVG component. If both props are provided it will defer to the image  -->
    <!-- {
      heroImg && (
        <CldImage
          src={heroImg}
          alt={heroImgAlt}
          class="w-full rounded-2xl"
          draggable="false"
          format="avif"
          priority
          width={640}
          height={427}
        />
      )
    }
    {heroSvg && !heroImg && <Icon name={heroSvg} class="size-full" />} -->
    <AnimatedHeroSvg />
  </div>
</section>

<!-- GSAP animation for typing effect on Hero Title -->
<script>
  import { gsap } from "gsap";

  // Store the master timeline globally so we can properly clean it up
  let masterTimeline: gsap.core.Timeline | null = null;

  function inittyping() {
    const subtitle = document.getElementById("typing-subtitle");
    const typingSpan = subtitle?.querySelector(".typing-text") as HTMLElement;
    const cursor = subtitle?.querySelector(".typing-cursor") as HTMLElement;

    if (!subtitle || !typingSpan || !cursor) return;

    // Get titles from data attribute or fallback to nothing
    const titles = subtitle.dataset.typingTitles;
    const animateTitles = JSON.parse(titles ?? "[]");

    if (!animateTitles || animateTitles.length === 0) return;

    // Kill any existing master timeline and its children
    if (masterTimeline) {
      masterTimeline.kill();
      masterTimeline = null;
    }

    // Kill any existing animations to prevent conflicts
    gsap.killTweensOf([typingSpan, cursor]);

    // Clear any existing content and reset state
    typingSpan.textContent = "";
    gsap.set(cursor, { opacity: 0 });

    function typeText(text: string) {
      const chars = text.split("");
      const typeTimeline = gsap.timeline();

      // Show cursor at the start of typing
      typeTimeline.set(cursor, { opacity: 1 }, 0);

      // Type each character using proper GSAP timing
      chars.forEach((_, index) => {
        typeTimeline.to(
          typingSpan,
          {
            duration: 0.05,
            onStart: () => {
              typingSpan.textContent = text.substring(0, index + 1);
            },
          },
          index * 0.05,
        );
      });

      return typeTimeline;
    }

    function eraseText() {
      const currentText = typingSpan.textContent || "";
      const eraseTimeline = gsap.timeline();

      // Keep cursor visible during erasing
      eraseTimeline.set(cursor, { opacity: 1 }, 0);

      // Erase each character (faster than typing)
      for (let i = currentText.length; i > 0; i--) {
        eraseTimeline.to(
          typingSpan,
          {
            duration: 0.03,
            onStart: () => {
              typingSpan.textContent = currentText.substring(0, i - 1);
            },
          },
          (currentText.length - i) * 0.03,
        );
      }

      return eraseTimeline;
    }

    function startCycle() {
      // Create the master timeline with repeat
      masterTimeline = gsap.timeline({ repeat: -1 });

      animateTitles.forEach((text: string) => {
        if (masterTimeline) {
          // Type the text
          masterTimeline.add(typeText(text));
          // Wait for 3 seconds with cursor visible
          masterTimeline.to({}, { duration: 3 });
          // Erase the text
          masterTimeline.add(eraseText());
          // Small pause between words
          masterTimeline.to({}, { duration: 0.5 });
        }
      });
    }

    // Start the cycle immediately (no delay needed)
    startCycle();
  }

  // Use a single event listener that works for both initial load and View Transitions
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", inittyping);
  } else {
    // DOM is already ready, initialize immediately
    inittyping();
  }

  // Re-initialize after View Transitions
  document.addEventListener("astro:page-load", inittyping);
</script>
